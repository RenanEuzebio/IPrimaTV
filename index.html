<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>M3U Live Player with Channel List</title>

    <!-- HLS.js for .m3u8 -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <!-- mpegts.js for .ts MPEG-TS streams -->
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js@latest"></script>

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        height: 100vh;
        display: flex;
        overflow: hidden;
        background: #000;
      }

      /* Container for sidebar + player */
      #layout {
        display: flex;
        flex: 1;
        height: 100%;
      }

      /* Sidebar */
      #sidebar {
        width: 300px;
        display: flex;
        flex-direction: column;
        border-right: 2px solid #444;
        background: #111;
        color: #eee;
        transition: width 0.3s ease, padding 0.3s ease,
          border-right 0.3s ease;
      }

      #sidebar-inner {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      #search {
        margin: 10px;
        padding: 6px 8px;
        border-radius: 4px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        outline: none;
      }

      #search::placeholder {
        color: #888;
      }

      #channels {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
      }

      .channel {
        padding: 6px 8px;
        margin-bottom: 5px;
        cursor: pointer;
        background: #222;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .channel:hover {
        background: #333;
      }

      .channel img {
        width: 32px;
        height: 32px;
        object-fit: contain;
        background: #000;
        border-radius: 4px;
        flex-shrink: 0;
      }

      .channel-text {
        display: flex;
        flex-direction: column;
      }

      .channel-name {
        font-size: 14px;
      }

      .channel-group {
        font-size: 11px;
        color: #aaa;
      }

      /* Player */
      #player {
        flex: 1;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.3s ease;
        position: relative;
      }

      video {
        width: 90%;
        height: auto;
        background: black;
        transition: width 0.3s ease, height 0.3s ease;
      }

      /* Sidebar collapse toggle button (always visible) */
      #toggleSidebar {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        padding: 5px 10px;
        font-size: 12px;
        border-radius: 4px;
        border: 1px solid #444;
        background: rgba(0, 0, 0, 0.7);
        color: #eee;
        cursor: pointer;
      }

      #toggleSidebar:hover {
        background: rgba(50, 50, 50, 0.9);
      }

      /* Collapsed state */
      body.sidebar-collapsed #sidebar {
        width: 0;
        padding: 0;
        border-right: none;
      }

      body.sidebar-collapsed #sidebar-inner {
        display: none;
      }

      body.sidebar-collapsed #player video {
        width: 98%;
        height: 98%;
      }
    </style>
  </head>

  <body>
    <div id="layout">
      <!-- Sidebar -->
      <div id="sidebar">
        <div id="sidebar-inner">
          <input
            id="search"
            type="text"
            placeholder="Search channels..."
          />
          <div id="channels">Loading channels…</div>
        </div>
      </div>

      <!-- Player -->
      <div id="player">
        <button id="toggleSidebar">Hide channels</button>
        <video id="video" controls></video>
      </div>
    </div>

    <script>
      // No proxy at all – URLs are used directly.

      let hlsInstance = null;
      let tsPlayer = null;
      let allChannels = [];

      async function playStream(url) {
        const video = document.getElementById("video");

        // Clean up previous players
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        if (tsPlayer) {
          tsPlayer.destroy();
          tsPlayer = null;
        }

        video.onended = null;

        const lower = url.toLowerCase();
        const isM3U8 = lower.includes(".m3u8");
        const isTS = lower.endsWith(".ts");

        // --- Case 1: HLS playlist (.m3u8) ---
        if (isM3U8 && Hls.isSupported()) {
          try {
            console.log("Playing HLS playlist directly:", url);

            hlsInstance = new Hls({
              liveDurationInfinity: true,
              enableWorker: true,
            });
            hlsInstance.loadSource(url);
            hlsInstance.attachMedia(video);
            hlsInstance.on(Hls.Events.MEDIA_ATTACHED, () => {
              video.play().catch(() => {});
            });
          } catch (e) {
            console.error("Error loading HLS stream:", e);
          }
          return;
        }

        // --- Case 2: raw MPEG-TS (.ts) via mpegts.js (live) ---
        if (isTS && window.mpegts && mpegts.isSupported()) {
          console.log("Playing MPEG-TS via mpegts.js (live):", url);

          tsPlayer = mpegts.createPlayer(
            {
              type: "mpegts",
              url: url,
              isLive: true,
            },
            {
              enableWorker: true,
              enableStashBuffer: true,
              stashInitialSize: 256 * 1024,
            }
          );

          tsPlayer.attachMediaElement(video);
          tsPlayer.load();
          tsPlayer.play().catch(() => {});

          tsPlayer.on(mpegts.Events.ERROR, (type, details, info) => {
            console.warn("mpegts error:", type, details, info || "");
          });

          video.onended = () => {
            console.warn(
              "Stream ended (connection closed). If it is a true live " +
                "stream, the server should keep sending data."
            );
          };

          return;
        }

        // --- Case 3: fallback (mp4, etc.) ---
        console.log("Playing direct stream (fallback):", url);
        video.src = url;
        video.play().catch(() => {});
      }

      // Try lista.m3u8, then lista.m3u
      async function fetchPlaylistText() {
        const candidates = ["lista.m3u8", "lista.m3u"];
        for (const filename of candidates) {
          try {
            const res = await fetch(filename);
            if (res.ok) {
              console.log("Loaded playlist:", filename);
              return await res.text();
            }
          } catch (e) {
            // try next
          }
        }
        throw new Error(
          "No playlist file found (lista.m3u8 or lista.m3u)"
        );
      }

      function parseExtInf(line) {
        const comma = line.lastIndexOf(",");
        const name =
          comma !== -1
            ? line.substring(comma + 1).trim()
            : "Unnamed channel";

        const logoMatch = line.match(/tvg-logo="([^"]*)"/i);
        const logo = logoMatch ? logoMatch[1] : "";

        const groupMatch = line.match(/group-title="([^"]*)"/i);
        const group = groupMatch ? groupMatch[1] : "";

        return { name, logo, group };
      }

      async function loadChannelList() {
        try {
          const text = await fetchPlaylistText();
          const lines = text.split(/\r?\n/);

          const channels = [];
          let currentMeta = { name: "", logo: "", group: "" };

          for (let line of lines) {
            line = line.trim();
            if (!line) continue;

            if (line.startsWith("#EXTINF")) {
              currentMeta = parseExtInf(line);
            } else if (
              line.startsWith("http://") ||
              line.startsWith("https://")
            ) {
              channels.push({
                name: currentMeta.name,
                logo: currentMeta.logo,
                group: currentMeta.group,
                url: line,
              });
            }
          }

          allChannels = channels;
          renderChannelList(allChannels);

          if (channels.length > 0) {
            playStream(channels[0].url);
          }
        } catch (e) {
          console.error("Error loading playlist:", e);
          document.getElementById("channels").textContent =
            "Error loading lista.m3u8/lista.m3";
        }
      }

      function renderChannelList(channels) {
        const div = document.getElementById("channels");
        div.innerHTML = "";

        if (channels.length === 0) {
          div.textContent = "No channels found.";
          return;
        }

        channels.forEach((ch) => {
          const item = document.createElement("div");
          item.className = "channel";
          item.onclick = () => playStream(ch.url);

          if (ch.logo) {
            const img = document.createElement("img");
            img.src = ch.logo;
            img.alt = ch.name;
            item.appendChild(img);
          }

          const textWrap = document.createElement("div");
          textWrap.className = "channel-text";

          const nameEl = document.createElement("div");
          nameEl.className = "channel-name";
          nameEl.textContent = ch.name || ch.url;
          textWrap.appendChild(nameEl);

          if (ch.group) {
            const groupEl = document.createElement("div");
            groupEl.className = "channel-group";
            groupEl.textContent = ch.group;
            textWrap.appendChild(groupEl);
          }

          item.appendChild(textWrap);
          div.appendChild(item);
        });
      }

      function setupSearch() {
        const input = document.getElementById("search");
        input.addEventListener("input", () => {
          const q = input.value.toLowerCase().trim();
          if (!q) {
            renderChannelList(allChannels);
            return;
          }
          const filtered = allChannels.filter((ch) => {
            const name = (ch.name || "").toLowerCase();
            const group = (ch.group || "").toLowerCase();
            return name.includes(q) || group.includes(q);
          });
          renderChannelList(filtered);
        });
      }

      function setupSidebarToggle() {
        const btn = document.getElementById("toggleSidebar");
        btn.addEventListener("click", () => {
          const collapsed = document.body.classList.toggle(
            "sidebar-collapsed"
          );
          btn.textContent = collapsed ? "Show channels" : "Hide channels";
        });
      }

      // Init
      setupSearch();
      setupSidebarToggle();
      loadChannelList();
    </script>
  </body>
</html>
