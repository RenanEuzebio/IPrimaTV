<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>M3U Live Player - GitHub Pages</title>
    
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js@latest"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            background: #000;
        }
        #layout { display: flex; flex: 1; height: 100%; }
        #sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #444;
            background: #111;
            color: #eee;
            transition: width 0.3s ease, padding 0.3s ease, border-right 0.3s ease;
        }
        #sidebar-inner { display: flex; flex-direction: column; height: 100%; }
        #search {
            margin: 10px;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: #eee;
            outline: none;
        }
        #search::placeholder { color: #888; }
        #channels { flex: 1; overflow-y: auto; padding: 10px; }
        .channel {
            padding: 6px 8px;
            margin-bottom: 5px;
            cursor: pointer;
            background: #222;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .channel:hover { background: #333; }
        .channel img {
            width: 32px;
            height: 32px;
            object-fit: contain;
            background: #000;
            border-radius: 4px;
            flex-shrink: 0;
        }
        .channel-text { display: flex; flex-direction: column; }
        .channel-name { font-size: 14px; }
        .channel-group { font-size: 11px; color: #aaa; }
        #player {
            flex: 1;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            position: relative;
        }
        video {
            width: 90%;
            height: auto;
            background: black;
            transition: width 0.3s ease, height 0.3s ease;
        }
        #toggleSidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #444;
            background: rgba(0, 0, 0, 0.7);
            color: #eee;
            cursor: pointer;
        }
        #toggleSidebar:hover { background: rgba(50, 50, 50, 0.9); }
        body.sidebar-collapsed #sidebar { width: 0; padding: 0; border-right: none; }
        body.sidebar-collapsed #sidebar-inner { display: none; }
        body.sidebar-collapsed #player video { width: 98%; height: 98%; }
        .error-message {
            color: #ff6b6b;
            padding: 20px;
            text-align: center;
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid #ff6b6b;
            border-radius: 4px;
            margin: 10px;
        }
        .stream-info {
            color: #4CAF50;
            padding: 10px;
            text-align: center;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 4px;
            margin: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="layout">
        <div id="sidebar">
            <div id="sidebar-inner">
                <input id="search" type="text" placeholder="Search channels..." />
                <div id="channels">Loading channelsâ€¦</div>
            </div>
        </div>
        <div id="player">
            <button id="toggleSidebar">Hide channels</button>
            <video id="video" controls preload="none"></video>
        </div>
    </div>

    <script>
        // Self-hosted proxy configuration
        // IMPORTANT: Replace with your actual proxy server URL after deployment
        // Examples:
        //   - Local testing: "http://localhost:3000/proxy?url="
        //   - Production: "https://your-domain.com/proxy?url="
        const PROXY_URL = "http://localhost:3000/proxy?url=";

        // Optional: Set API key if your proxy server requires authentication
        // Leave empty if API_KEY is not configured on the server
        const API_KEY = "";  // e.g., "your-secret-api-key-here"

        // Toggle to enable/disable proxy (set to false to try direct connections)
        const USE_PROXY = true;

        function getProxiedUrl(url) {
            if (!USE_PROXY) {
                return url;
            }
            return PROXY_URL + encodeURIComponent(url);
        }

        let hlsInstance = null;
        let tsPlayer = null;
        let allChannels = [];

        async function playStream(url) {
            const video = document.getElementById("video");
            const errorDiv = document.getElementById("channels");
            
            // Clear any existing info messages
            const existingInfo = document.querySelector('.stream-info');
            if (existingInfo) existingInfo.remove();

            // Clean up previous players
            if (hlsInstance) { 
                hlsInstance.destroy(); 
                hlsInstance = null; 
            }
            if (tsPlayer) { 
                tsPlayer.destroy(); 
                tsPlayer = null; 
            }

            video.onended = null;
            video.src = ''; // Clear previous source

            const lower = url.toLowerCase();
            const isM3U8 = lower.includes(".m3u8");
            const isTS = lower.endsWith(".ts");

            console.log("Attempting to play:", { url, isM3U8, isTS });

            // Try different approaches based on stream type
            const streamInfo = document.createElement('div');
            streamInfo.className = 'stream-info';
            streamInfo.textContent = `Loading ${isM3U8 ? 'HLS' : 'TS'} stream${USE_PROXY ? ' via proxy' : ''}...`;
            document.getElementById("sidebar").appendChild(streamInfo);

            // Get proxied or direct URL
            const proxiedUrl = getProxiedUrl(url);
            console.log(`Stream URL: ${USE_PROXY ? 'Using proxy' : 'Direct connection'}`);

            // Approach 1: Try native video element first (works better for some servers)
            try {
                console.log("Approach 1: Native video element");
                const directUrl = proxiedUrl;
                
                video.src = directUrl;
                video.load();
                
                const playPromise = video.play();
                if (playPromise !== undefined) {
                    await playPromise;
                }
                
                console.log("Native playback successful!");
                streamInfo.textContent = "Playing via native player...";
                return;
            } catch (e) {
                console.warn("Native playback failed:", e.message);
            }

            // Approach 2: Try HLS.js for m3u8 streams
            if (isM3U8 && Hls.isSupported()) {
                try {
                    console.log("Approach 2: HLS.js");
                    streamInfo.textContent = "Trying HLS.js player...";

                    const hlsUrl = proxiedUrl;
                    
                    hlsInstance = new Hls({
                        liveDurationInfinity: true,
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });
                    
                    hlsInstance.loadSource(hlsUrl);
                    hlsInstance.attachMedia(video);
                    
                    hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
                        video.play().catch(() => {});
                    });
                    
                    hlsInstance.on(Hls.Events.ERROR, (event, data) => {
                        console.warn("HLS error:", data);
                        if (data.fatal) {
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    streamInfo.textContent = "Network error - trying alternative method...";
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    streamInfo.textContent = "Media error - stream may be corrupted";
                                    break;
                                default:
                                    streamInfo.textContent = "Fatal HLS error";
                                    break;
                            }
                        }
                    });
                    
                    return;
                } catch (e) {
                    console.warn("HLS.js failed:", e.message);
                }
            }

            // Approach 3: Try mpegts.js for TS streams
            if (isTS && window.mpegts && mpegts.isSupported()) {
                try {
                    console.log("Approach 3: mpegts.js");
                    streamInfo.textContent = "Trying mpegts.js player...";

                    const tsUrl = proxiedUrl;
                    
                    tsPlayer = mpegts.createPlayer({
                        type: "mpegts",
                        url: tsUrl,
                        isLive: true,
                    }, {
                        enableWorker: true,
                        enableStashBuffer: false, // Disable buffer for live streams
                        stashInitialSize: 128 * 1024,
                        autoCleanupSourceBuffer: true
                    });

                    tsPlayer.attachMediaElement(video);
                    tsPlayer.load();
                    
                    tsPlayer.on(mpegts.Events.ERROR, (type, details, info) => {
                        console.warn("mpegts error:", type, details, info || "");
                        if (type === mpegts.Events.ERROR) {
                            streamInfo.textContent = "MPEG-TS playback error";
                        }
                    });

                    video.play().catch(e => console.log("Play failed:", e));
                    return;
                } catch (e) {
                    console.warn("mpegts.js failed:", e.message);
                }
            }

            // All approaches failed
            streamInfo.remove();
            errorDiv.innerHTML = '<div class="error-message">Unable to load stream. This may be due to CORS restrictions, server protections, or the stream being offline. GitHub Pages has limited streaming capabilities.</div>';
        }

        // Playlist loading functions
        async function fetchPlaylistText() {
            const candidates = ["lista.m3u8", "lista.m3u"];
            for (const filename of candidates) {
                try {
                    const res = await fetch(filename);
                    if (res.ok) {
                        console.log("Loaded playlist:", filename);
                        return await res.text();
                    }
                } catch (e) { /* try next */ }
            }
            throw new Error("No playlist file found");
        }

        function parseExtInf(line) {
            const comma = line.lastIndexOf(",");
            const name = comma !== -1 ? line.substring(comma + 1).trim() : "Unnamed channel";
            const logoMatch = line.match(/tvg-logo="([^"]*)"/i);
            const logo = logoMatch ? logoMatch[1] : "";
            const groupMatch = line.match(/group-title="([^"]*)"/i);
            const group = groupMatch ? groupMatch[1] : "";
            return { name, logo, group };
        }

        async function loadChannelList() {
            try {
                const text = await fetchPlaylistText();
                const lines = text.split(/\r?\n/);
                const channels = [];
                let currentMeta = { name: "", logo: "", group: "" };

                for (let line of lines) {
                    line = line.trim();
                    if (!line) continue;

                    if (line.startsWith("#EXTINF")) {
                        currentMeta = parseExtInf(line);
                    } else if (line.startsWith("http://") || line.startsWith("https://")) {
                        channels.push({
                            name: currentMeta.name,
                            logo: currentMeta.logo,
                            group: currentMeta.group,
                            url: line,
                        });
                    }
                }

                allChannels = channels;
                renderChannelList(allChannels);
                if (channels.length > 0) playStream(channels[0].url);
            } catch (e) {
                console.error("Error loading playlist:", e);
                document.getElementById("channels").innerHTML = '<div class="error-message">Error loading playlist file.</div>';
            }
        }

        function renderChannelList(channels) {
            const div = document.getElementById("channels");
            div.innerHTML = "";

            if (channels.length === 0) {
                div.innerHTML = '<div class="error-message">No channels found.</div>';
                return;
            }

            channels.forEach(ch => {
                const item = document.createElement("div");
                item.className = "channel";
                item.onclick = () => playStream(ch.url);

                if (ch.logo) {
                    const img = document.createElement("img");
                    img.src = ch.logo;
                    img.alt = ch.name;
                    img.onerror = () => { img.style.display = 'none'; };
                    item.appendChild(img);
                }

                const textWrap = document.createElement("div");
                textWrap.className = "channel-text";

                const nameEl = document.createElement("div");
                nameEl.className = "channel-name";
                nameEl.textContent = ch.name || ch.url;
                textWrap.appendChild(nameEl);

                if (ch.group) {
                    const groupEl = document.createElement("div");
                    groupEl.className = "channel-group";
                    groupEl.textContent = ch.group;
                    textWrap.appendChild(groupEl);
                }

                item.appendChild(textWrap);
                div.appendChild(item);
            });
        }

        function setupSearch() {
            const input = document.getElementById("search");
            input.addEventListener("input", () => {
                const q = input.value.toLowerCase().trim();
                const filtered = q 
                    ? allChannels.filter(ch => {
                        const name = (ch.name || "").toLowerCase();
                        const group = (ch.group || "").toLowerCase();
                        return name.includes(q) || group.includes(q);
                      })
                    : allChannels;
                renderChannelList(filtered);
            });
        }

        function setupSidebarToggle() {
            const btn = document.getElementById("toggleSidebar");
            btn.addEventListener("click", () => {
                const collapsed = document.body.classList.toggle("sidebar-collapsed");
                btn.textContent = collapsed ? "Show channels" : "Hide channels";
            });
        }

        // Init
        setupSearch();
        setupSidebarToggle();
        loadChannelList();
    </script>
</body>
</html>
